# day014



1.在Python中，一切皆是对象，连函数语句都可以用变量函数名来绑定，所以函数语句也是对象。

2.在python的函数里面，如果想让内部的对象拿到外面来用，可以使用return ，因为函数中的对象也是用局部变量来绑定，函数开始创建对象用变量绑定，函数结束，局部变量消失，对象没有了变量绑定，也自动回收，为了让它不被回收，返回它，用别的变量来绑定。

3.python有四个作用域，从上到下，每个作用域有自己的变量命名空间，这也就保证了变量的不冲突，比如全局变量中有个x，函数中参数可以定义为x，另一个函数中参数也可以定义为x，它们都不冲突，因为它们在不同的作用域中，但是上一层是包含下一层的，在自己的作用域中未找到变量，再在上一层中寻找，没有就再到上一层查找。这也就是全局变量可在函数中使用的原因。他们是包含关系

自下而上是局部作用域，外部嵌套函数作用域（看情况有无)，函数所在模块（文件）作用域（全局），python内置函数作用域（有max,len,min,sum等变量）

如果我们在全局下定义一个max等，就先查找自己，有了就不会查找上一层

global a 就是声明a变量是模块级的作用域（全局），以后操作a都是在全局的作用域内

global a语句要在最前面，不能先创建局部变量a,再声明a是全局变量

比如                  

```python
a=110
def ok():
    a=130
    global a            告诉在这个函数中a 都将是全局变量
    
def ok(a):   已经创建局部变量a
    global a 
    a=150                        这样都是语法错误，会产生冲突
```

有了global还不够，如果我想要在内嵌函数中声明改变外嵌套变量绑定的对象呢，用nonlocal a，声明a是外嵌套函数作用域中的a

当有两层或者多层函数嵌套中使用，那么nonlocal只对最近的上一层使用，因为那个时候相对于用的那一层，它的外嵌套函数是上一层，至于再上一层那是上一层的外嵌套函数

注意nonlocal只能在内嵌函数内部中使用，你不可能还跑到上一级中去了，因为函数执行完，变量就销毁

global和nonlocal都是告诉在函数中是全局变量  外嵌套函数变量

总是一个作用域中只能有且仅有唯一的变量名，看怎么变

4.lambda

```python
def myadd(x,y):
    return x+y
就等同于
myadd=lambda x,y:x+y     用匿名函数表达式来操作生成函数代码块，赋值给变量myadd，和上面函数功能一模一样
                         连变量名都一样
>>> myadd=lambda x,y:x+y
>>> myadd(1,2)
3
>>> myadd
<function <lambda> at 0x7fe53d988f28>      但是函数名似乎变成了lambda就是没有名字的函数
(lambda x:x**2)(2) 
4
```

