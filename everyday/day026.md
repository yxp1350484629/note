

# day026

1.for 循环既可以处理可迭代对象，有可以用来处理迭代器和生成器

生成器对象要么是函数对象，要么是表达式对象，它既有可迭代对象的性质，可用for迭代。又有迭代器的性质

注意迭代器只能使用一次，想要再次使用就不行，因为到最后只能返回错误，想要在程序中重新使用这个对象也不行，注意生成器也是用next，所以他也只能使用一次

注意迭代器函数每次执行，都会生成一个生成器对象，而一个生成器对象只能使用一次

函数每执行一次都是一个全新的函数对象，有自己的变量域，至于对象的调用，就不太清楚了。我觉得确实是不同的对象，这是毋庸置疑的，但是自己的变量域内绑定的一些对象是可以重复绑定的，也就是引用计数加一，节省了内存

每次next返回的都是yield返回的对象

2.

```python3
def pii():
    print('l')
    yield 1
    yield 2
    print('p')
    yield 3
a=pii()       创建生成器对象
print(next(a),next(a),next(a))  因为这是一个表达式，要得到里面的三个对象，需要迭代三次，所以l,p就
                              首先输出出来了，返回的1,2,3就给了三个对象
                
                
l 
p
1 2 3
a=pii()又创建一个新的生成器对象，就可以重新进行迭代了
print(next(a))           由于这里是三个表达式，一次一次执行，得到第一个表达式中的对象，需要执行l，得到
print(next(a))           第三个表达式中的对象。。。。。 也就是一个执行的关系
print(next(a))           前面是一个表达式需要得到那三个对象，就会一次性执行完，得到值，这个一次次一次
                       执行


l  
1
2
p
3
```

3.

next(生成器函数())先执行括号里面的，生成一个生成器对象，，然后执行next()，每次找生成器对象要数据，生成器对象才生成一个对象，然后有变量绑定就绑定，没变量绑定的对象就释放了，也就大大节约了空间，你要的时候才生成，不需要先用一个容器存储，浪费大量空间

所以说生成器对象里面根本就没有数据，你要的时候他才会生成返回

注意range函数它是一个可迭代对象

4.list(生成器对象)

相当于用next把生成器对象都迭代了一遍，然后放在了列表里面，注意set也行

list(range(1000000000000000)) 系统就崩溃掉了，因为系统存不了那么多数据

range(10000000000000000) 系统 没有什么事情，因为range相当于一个生成器，里面没有什么数据，都是现生成？？？

5.生成器函数里面不能有return ,如果有，一定会在执行到return语句的时候，返回StopIteration:return返回的对象

6.迭代器，生成器中的next方法，当没有数据可以返回时，就返回Stop错误，就是要数据的时候给不了，会有对象抛出异常，但具体是谁抛出，不太清楚，当生成器函数中，有next抛出异常，外层有for的时候，会自动捕获，并且不会往下走，相当于except 空

7.sys.exit(0)虽然是正常退出，但是是相当于异常的，是直接推出到python交互界面，下面的程序是绝对不会执行的，应该把它当作一个异常退出，如果这个是在一个函数里面，调用了这个函数，下面的语句是不会执行的，千万别忘了。

