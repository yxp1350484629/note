# day049（TCP）

1.注意listen方法是为了控制连接的申请，也就是说同一时间内最大的连接申请数，也是一个队列机制，同一时间也有先后。具体底层实现不需要太了解。

2.客户端执行 ctrl+c 报出的异常是keyboardinterrupt

3.客户端服务端无论连接的哪一方退出，recv都会立即返回空字串，不再阻塞

4.当连接的有一端退出的时候，另一端再send，就会出现BrokenPipeError异常

5.代码见pythonNet day1 (**重点**)

服务器的tcp套接字对象相当于控制服务器端的创建开关等事宜，socket对象关闭服务器就关闭了

用tcp套接字创建的客户端套接字，相当于一个管道。它关闭(自然关闭，异常关闭，ctrl+c)相当于一个管道的关闭，数据就无法传输，如果客户端需要recv，就会得到空

而客户端也需要用socket对象创建关键字，客户端的这个tcp关键字，相当于有客户端和管道的功能，把他们合在一起了，因为它不需要能有多个连接，所以相对于服务端就少了很多步骤，它的关闭是客户端和管道都关闭，另一端的recv就会得到空

6.send,recv实际上都是和缓冲区进行的交互,send是发送到发送缓冲区，然后通过操作系统，将数据通过底层发送，然后会发送到另一端的接收缓冲区里面，recv就是从接受缓冲区接收数据

客观上来讲,sen,recv都是阻塞函数，当发送缓冲区数据满，send就阻塞了，当接收缓冲区数据为空，recv就阻塞了

既然recv是通过缓冲区进行接收，当send发送的数据过多，而recv后面参数小，也就是一次接收的数据少，那么就只会接收参数给定的数据，剩下的数据会留在缓冲区里，一般recv都会加上循环，那么剩下的数据就会在下一次循环读入，当然如果没有循环接受，而是管道关闭，数据就没了

所有的缓冲区都是为了协调控制收发速度，减少交互次数，用最好的次数，最适当的速度频率

7.tcp流式套接字当一方持续发送过快，另一方来不及接受，数据会堆在接收缓冲区，由于tcp如水一样的数据，另一方接收的时候，接收多少字节，会索性全部接收，这样前后发送的内容堆积在一起，形成粘包

处理方法：1.每次发送消息，在后面添加标识，这样接收消息后，可以根据标识处理

​                   2.发送结构体的数据

​                   3.在重复发送之前，可以先sleep，这样可以给另一端足够的时间接收，一般停留0.1s

8.udp数据报套接字和tcp流式套接字最大的区别就是不需要建立准确的连接，谁都可以发送信息过来，我也可以任意给谁发送，不管对方接收如何，特别特别随意。当然tcp只能给tcp发，udp只能给udp发

所以udp服务端的过程省去了建立连接的过程，只需要创建socket套接字，一个bind，就建立了服务器，然后通过socket对象，接收，发送信息，两个函数，recvfrom返回接收数据和发送客户端地址，参数为字节数。sendto发送数据根据前面返回的客户端地址。服务端关闭不受客户端任何影响，我想怎样就怎样。