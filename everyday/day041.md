# day041

1.

e in 对象，注意这个是针对对象中的contains方法，大致于是这样 __ contains __(self,e),e in self,是针对后面对象的，肯定要调用后面对象的方法，有了in 运算符的重载（注意in运算符重载一般返回True，False)，not in就不用再重载方法了，只需要in方法就行了，not不需要重载什么，直接加在前面就行了。就和 is not不需要重载一样，not本就是个固定运算符，和is一样。

**运算符重载重要还是弄清楚要返回什么，是返回新对象，还是返回自己，得逻辑判断清楚**

2.

```python
    def __getitem__(self,e):    返回索引的方法__getitem__，a[1]很明显需要两个参数,self和索引
        return self.data[e]     
    def __setitem__(self,e,v): 索引赋值，切记方法返回的都是一个对象，对象是不能赋值的，他不是一个变量
        self.data[e]=v         我们看方法返回好像是个变量，一定要明白是一个对象，我之前也觉得只需要getitem就行了返回一个a[1]，然后赋值嘛，大错特错了，返回的是对象，怎能赋值呢，方法返回的东西永远不能赋值，那么列表索引是怎样进行赋值操作的呢，只能通过别的方法，在方法里面进行赋值，不用返回任何东西，这个setitem就相当于把所有工作都做了，它相当于[]和=。这个方法可以给我们借鉴，以后自己设计方法，对返回的东西赋值也只能这样。直接在方法里改变。
    def __delitem__(self,e):
        del self.data[e]      这个也不需要返回什么，直接在方法里删除了索引
```

注意a[::2]也能传入上面的getitem方法，里面的::2作为e传入，注意::2也是一个对象，是slice类创建的对象，相当于slice(None,None,2),其实列表切片也是调用了getitem方法，也是将slice创建的对象传入0