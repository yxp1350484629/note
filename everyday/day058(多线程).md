# day058(多线程)

1.进程是系统分配资源最小的单位，系统是不会单独为线程分配资源的，所以线程必须依赖于进程的资源，这个资源也就是指独立的内存空间那些和计算资源。

线程是cpu时间片分配的最小单位，线程依赖于进程得到操作系统的计算资源。操作系统可以分配计算资源给进程，进程再把这些给单个线程。如果没有线程，单个时间点，每个cpu核上只能有一个进程，有了线程，单独cpu核上只能由一个线程，所以线程是占用cpu核，也就是得到cpu计算资源的最小单位

如果计算集只有单核，那么运行一个程序，始终只能单核多线程，就是一个进程里的多个线程在轮流占用这个核

如果计算机有多核，即使只有一个进程，那么这个进程里多个线程也可以占用多个核，达到并行并发

2.进程开辟一个独立的空间，而线程相当于主进程的一个分支，而一般这个时候主进程就叫做主线程了，其余的线程都叫做分支线程，不同线程之间运行互不干扰，由于他们都在一个对象空间内，所以共享主线程的全局变量，但是每个线程也有自己独立的局部变量域，因为线程代码都在函数内

3.创建线程

threading.Thread()创建线程对象，在主线程中这样创建就相当于创建了一个分支线程。

后面的参数和进程对象创建参数一样。name,target,args,kwargs

线程对象也需要start,join。注意线程对象也需要join（timeout)，虽然不会占用系统资源，但是也会消耗进程的资源

注意在python中是进程对象创建仿照的线程对象创建，其它语言中一般只有fork来创建进程

线程对象有几个方法，t.name  t.getname() t.setname是在主线程中对线程对象名进程操作 t.is_live()判断线程生存

threading.currentThread() 是可以在分支进程函数内访问自身线程对象。

t.daemon 默认为False，主线程退出不影响分支线程执行，t.daemon=True 主线程退出分支线程也结束

t.isdaemon()判断daemon的状态 

4.自定义线程类

start()方法

开始线程活动。

**对每一个线程对象来说它只能被调用一次，它安排对象在一个另外的单独线程中调用run()方法（而非当前所处线程）。也就是主线程用start，然后在分支进程中调用了run**

当该方法在同一个线程对象中被调用超过一次时，会引入RuntimeError(运行时错误)。

run()方法

代表了线程活动的方法。

你可以在子类中重写此方法。标准run()方法调用了传递给对象的构造函数的可调对象作为目标参数，如果有这样的参数的话，顺序和关键字参数分别从args和kargs取得。

创建自定义线程和自定义进程一样的流程，其实target在原线程类中是默认为None的**，即使target为None，还是会在分支进程中调用run，感觉在原线程类中的run，一定用到了target,主要就是使用target中的功能**

5.**在主线程中加一个分支线程也就相当于在这个空间里，执行了一个函数，不过是在另一条线程中，相当于增加了一条路，但是从全局看，就相当于全局变量域和局部变量域**

6.线程之间的通信，主要依赖于全局变量。线程间对于全局变量资源的同步互斥利用，主要依赖于事件和锁