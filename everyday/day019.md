# day019

1.装饰器

装饰器函数，也相当于一个闭包函数，把被装饰的函数传入，定义一个新的函数，在新函数中执行被装饰函数功能，同时添加新的功能，然后返回新的函数

执行情况是在原有函数def 的上面添加@装饰器函数变量名

然后在下面执行原函数变量就行了

其实是一个偷梁换柱，这个时候的原函数变量绑定的已经不是以前的函数，而是装饰器函数中返回的新函数

@装饰器变量名的作用是相当于在原def 语句下面添加了这样一条语句:

原函数变量名=装饰器函数名（原函数变量名）

在做项目的时候，我们往往需要修改一个函数的功能，**为了不在各处进行调试，使用装饰器是最简单安全的**。

2.注意的是，装饰器函数是将原函数传入，如果原函数有参数，不能在装饰器那里传入，我的想法是在生成器参数哪里传入，大错特错了，他本身是返回新函数的，然后又用原函数变量名来绑定，这样只需要在新函数哪里，定义和原函数一样的参数就行了，没那么返回之后直接调用就能直接赋参数了

犯的错误，注意，内嵌套函数不太需要外嵌套局部变量做参数，如果直接在外嵌套函数内调用，直接用上面的参数就行了，如果要返回到外部，那需要外部的对象做参数就行。

3.help(函数)

返回的函数下面的解释，其实是文档字符串，写python函数的人有心这样做的。用文档字符串做解释，那么以后别人用你的函数，直接用help就会看得很明白。

4.其实文档字符串是有变量绑定的，是对象的属性变量，整个函数代码就是一个对象，对象都是由属性的，

fx._ doc_属性变量就是绑定的文档字符串，fx. _name _ 就是绑定函数对象的名字，值得一提的是函数对象的名字从创建开始就固定了，无论怎么赋值，都不变，lambda创建的函数无论怎么赋值函数名字都是lambda

5.python的bug

缺省参数值（默认参数），从函数对象创建，就一直存在，相当于函数对象的一个内部属性绑定的一样在里面，他不会消失，也不是每次def 创建一个缺省参数值对象，而是一直存在，如果传入了就是局部变量，没传入，它是对象内部属性绑定的对象，如果这个绑定的这个对象是个不可变对象，那么在函数中改变值，也就直接指向别的对象了，在结束后销毁那个对象，第二次用缺省v参数还是绑定的那个不可变对象。但如果缺省参数绑定的是一个可变对象，如列表，那么除了赋值等以外会和上面进行一样的操作，如果进行append等直接改变对象的操作，那么改变之后的对象肯定也保留了，因为始终绑定那个对象，是对象改变了。

缺省参数要尽量避免绑定可变对象，如果实在要绑定，就将可变对象绑定为None,然后在下面加一行代码

if 缺省参数 is None:

​     缺省参数=可变对象

这样就相当于创建了一个局部变量，也不改变绑定值，也就避免了错误。

**默认参数值是内部属性绑定的对象。**

**参数绑定，相当于这个对象引用计数加一。**