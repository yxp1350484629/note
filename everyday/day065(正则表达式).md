# day065(正则表达式)

1.正则表达式的意义：是为了解决纯逻辑匹配，搜索文本比较复杂的问题，用一些普通字符和**特殊的符号**组成字串，来对文本进行匹配，搜索的高级文本匹配处理方法

目标：必须掌握正则表达式符号，能实现基本的文本搜索定位提取，能使用python中的re

正则表达式的难点就在于它的灵活性，千变万化



2.re模块

相关函数

re.findall(pattern,string)

第一个参数为正则表达式，第二个参数为要匹配的字符换，返回为一个列表，为匹配到的内容



3.元字符使用（记住所有）

普通字符：就是我们普通的字符比如a,b,c....以及汉字，不是元字符，没有特殊意义的字符，即除了元字符，就是普通字符

在正则表达式内部，每个字符都是独立的，由一个个组成的，但是在匹配的时候，是按照整个正则表达式整体进行匹配，从目标字符串开头依依次进行搜索，已经匹配到的字符，不会再重复进行，就是匹配到那，继续匹配时会从匹配到的字符串的下一个字符开始。

元字符

| 或字符  ab|cd 就是匹配目标字符串中的ab,或者cd 字符

. 匹配除了换行符以外的所有单个字符

^ 匹配字符串的开头位置，它必须位于正则表达式的开头，它后面接的正则表达式符必须匹配到的是从目标字符串开始的字符，所以有^的正则表达式它最多只能匹配一个字符串

$ 匹配字符串的结束位置，他必须位于正则表达式的最后，和^是相反的，但是也最多只能匹配到一个字符串

**匹配重复（重要）**

*表示可以匹配0个或多个前一个字符，比如 

fo* 表示可以匹配0个或多个o,注意这个时候基本上 o*是连在一起的，是一个字符，它们可以匹配f到f后面n个o

正则表达式不要f*这样的话可以匹配0个或多个f,就会每个都匹配到，返回空字串，因为其实字符串内每个字符之间以及最后都会有''空字串。

+号是匹配一个或多个前一个字符，它必须有一个，就没有上面的匹配空的情况了 如果 .+可以匹配1到多个任意字符

想要匹配所有.py结尾的文件名,可以.+\\.py $

感觉想.+ .* 在匹配目标字符串时，匹配是尽可能地匹配多的字符，虽然是匹配一到多，0到多，但只要满足条件，有多少就匹配多少，.*如果把整个目标字符串匹配完，还会匹配一个'',因为字符串是以''为结尾标识

？可以匹配0个或1一个前面一个字符，也是和前面那个字符连在一起，比如fo? 只能匹配f,fo

{n}可以指定n的大小，然后可以匹配前面一个字符出现n次的字符串，比如fo{3}，之可以匹配fooo

{m,n}可以匹配正则表达式中前一个字符出现m到n的次数，比如fo{2,4},可以匹配foo,fooo,foooo

*和?都可以表示可有可没有得意思，而 前者是可以没有可以有很多个，后者是可以没有，可以有一个

写一个正则表达式匹配整数，正数，负数，小数，分数

r'-?\d*\\.?/?\d\*'   符号，小数点，分数，都可有或只有一个。

**匹配字符集合**

[字符集] 一般就是[a-z],[A-Z],[0-9] 可以匹配字符集中任意一个字符，但是每次只能匹配一个

当然也可以[_123a-z] 这种混合的最好a-z这种要写到后面

为什么说正则表达式内部是独立，但是匹配的时候却要按照一个整体来匹配，比如[a-z]，它的涵义就是匹配一个字符。这是它的单独含义，但是后面加上+，就可以匹配一到多个a-z，但是匹配的时候是不会按照[a-z]这样单个特殊字符来匹配，一定是按照它前后的符号一起来匹配

所以正则表达式的关键在于每个字符都有它独特的含义，但是匹配起来要按照整体匹配

匹配开头首字母必须大写，后面可以有任意多个小写字符的正则表达式 ^[A-Z]【a-z】*  格式问题用

[字符集]的最前面还可以加^, 这就不是表示开头的意思了，表示非得意思，就是除了这里面的字符外，都可以匹配，但只能匹配一个

[^abc] 匹配非a,b,c字符

[^ ] 这是匹配非空格内字符，可以把一句话中所有单词取出来

**匹配任意（非）数字字符**

\d 匹配任意单个数字字符，相当于[0-9]

\D匹配任意单个非数字字符 相当于 【^0-9】

当然也可以\d+等，尽可能匹配多的连串数字字符

**匹配任意（非）普通字符**

注意这个普通字符，非普通字符不是正则表达式中得什么普通字符，特殊字符，它是指匹配目标字符串中得（非）普通字符

\w匹配单个普通字符，指数字字母下划线，也能匹配utf8汉字,相当于[_0-9a-zA-Z] 还有汉字

\W匹配单个非普通字符，也就是百分号啊什么，除了普通字符的都是非普通字符，也包含所有空字符

**匹配任意（非）空字符**

\s 匹配任意空字符 [ \t\r\n\v\f]    \W也能匹配这个，但是这个也有存在的意义，太灵活

\S 匹配任意非空字符  除了上面空字符，全是非空字符

匹配字符串位置

\A 相当于^ \Z 相当于$  现在用\A \Z的人不多了

**绝对匹配**：指正则表达式必须要完全匹配目标字符串的内容，也就是必须要把目标字符串全部一次性匹配上，不能只匹配部分

在很多地方，比如给url地址，必须完全要按照我的格式匹配上，才可以用

绝对匹配一般用这样的正则表达式 ，以^，、A开头，$，\Z结尾的正则表达式，中间是要匹配的格式，这样无论如何，只有满足中间格式的目标字符串才能被返回

匹配（非）单词边界

单词边界就是目标字符串中普通字符与非普通字符之间，比如‘a*’, 边界就相当于之间的一条线 

'a|*'  而普通字符与普通字符之间，非普通字符与非普通字符之间相当于有一条非单词边界线

\b表示单词边界，\B表示非单词边界，注意字符串开头结尾也都有一条单词边界线

有\b在的正则表达式前面要加r，表示原始字符

re.findall(r'\b\w+','num')  -> num



总结：

每个正则表达式符的独立意义，分为三类

匹配单个字符：普通字符    .   \d \D \s \S \w \W [字符集] 【^字符集】

匹配重复字符 :  * + ? {n}  {m,n}

匹配边界：^ $ \A \Z \b \B

其他：|或          ()括号          \ 转义



**正则表达式转义（重点）**

要对正则表达式进行正确匹配的重要前提是，正则表示式必须作为字符串传入到函数中，然后会经过python对于字符串的解释，必须要python对字符串的解释结果是我们想要的正确正则表达式，才能正确匹配

而正则表达式想要表达普通的 * ，$等符号，必须在这些符号前面加上\，以及我们将普通的b,w等加上\让它们变成正确的特殊字符。当我们把有\的正则表达式以字符串形式传入函数，会先经过python解释，然后根据它解释的意思进行匹配，而python本身的\也是特殊字符，python对于有\的字符串也需要进行转义

当我们python不认识正则表达式字符串中的转义字符，也只能当它是怎么样就怎么样

比如我们要匹配$字符，我们可以'\ $'，这样python并不认识它，也只能当作它是'\ $'这样解释

为什么之前的\b要前面加r，因为python中\b有特殊含义，然后python按照这个特殊含义解释正则表达式，解释的意思就变成了那个特殊含义，而在目标字符串内找不到这个特殊含义，就会匹配不到

我们还要经历python的转义，就必须\ \b，或者r'b'

在前面加r是原始字符串的意思，就是不经过转义，原封不动的解释，整个字符串是什么样就是什么样

**我们需要记住一条原则，当带有\的正则表达式，一定在前面加上r，然后写需要的正则表达式格式就行了**

当然在r''中加\的只有元字符，以及表示和元字符一样的普通字符，以及\，什么制表，换行什么都不需要再加\



匹配重复字符的贪婪模式和非贪婪模式

当我们用* + ? {m,n}的时候，它会尽可能地匹配多的字符，和人类一样是贪婪的

我们也可以把它变成非贪婪模式，在*,+,?,{m,n}的后面接一个?号，就变为非贪婪模式，尽可能匹配少的字符

和我们人类一样经过反思和思考就变得不贪婪了，所以在后面加个？



正则表达式的子组

在正则表达式中，用（）括起来的部分就是正则表达式的子组

子组可以看成是正则表达式中的一个小整体，整个正则表达式是一个大整体，相当于整体中的整体

当然也要原则还是看整个能不能匹配上，这样小整体才有发挥的空间

子组可以影响两种特殊字符

第一种是匹配重复的字符，比如(ab)+,这样就可以匹配多个ab

另一种是|，在正则表达式中的|是左边或者右边，相当于把大整体分成了两半，我们可以把|放在括号中，就是把小整体分为两半，比如我们要匹配.com或者.cn 

可以r'.\ (com|cn)'

可以单独提取出子组匹配到的内容

子组可以有多个，可以嵌套。一般我们从外到内，从左到右来划分子组的顺序，r'((ab)cd)(fb)' 这样第一组就是

((ab)cd),第二组就是(ab)，第三组就是(fb)从外到内，从左到右。一般我们可以通过group()来访问整个匹配的结果。用group(1)访问第一组，group(2)访问第二组，依次类推，我们一般不嵌套多个子组

子组的捕获组和非捕获组

捕获组又叫命名组，也就是可以给子组命名，比如（?P<name\>该放的内容) 这就是一个捕获组，有自己的名字，这个最大的作用就是可以通过组名来访问这个组匹配到的字符串，比如group(name)





