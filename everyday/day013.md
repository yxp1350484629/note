# day013

1.'int' object is not callable 

这个错误要么是int计算中出现问题，比如我用2(x+1)就不符合python规则

还有一种情况是函数名和变量名一样，用的时候分不清楚

2.函数的形参也是局部变量，而且局部变量只在函数调用时才创建，结束后函数内部的局部变量自动回收

3.

```python
a,b=1,5
>>> def ij(c):
...   print(a)
...   a=1        在函数中的变量赋值都是创建局部变量
...   print(b,c)
... 
>>> ij(4)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in ij
UnboundLocalError: local variable 'a' referenced before assignment
注意的是，在Python解释器中一个函数里面，只能有变量名是局部变量或者是全局变量，在函数中也可以直接访问全局变量，全局变量是所有都可以直接访问，一开始的print(a)，a是以全局变量的身份出现，后面的赋值又以局部变量的形式出现，就冲突了。
def ij(c):
...   a=1
...   print(a)
...   print(b,c)
... 
>>> ij(4)       这样就没什么问题，在函数中，a一开始就是以局部变量的形式出现
1 
5 4
```

如何在函数中改变全局变量呢

```python
def ju():
...   a=3
...           
>>> ju()   如果你想这样做就大错特错了，虽然函数可以直接访问全局，但是在函数中赋值是创建局部变量
>>> a

>>> def ju():
...   global a    只能在函数中声明a是全局变量，那么a=3就是直接给全局变量a赋值了
...   a=3
... 
>>> ju()
>>> a
3

```

一般来说，函数内部是不会轻易让你破坏全局变量的，这是为了函数的安全性

永远记住，在函数中没有global 全局变量的情况下，赋值语句不能对全局变量造成影响

```python
def jy(x):
...   x.append('c')
... 
>>> L=[]
>>> jy(L)    只要一个变量域中不出现两个相同的变量都是可以的，全局变量可以拿到局部变量域中使用，因为它在
>>> L        外层，但是在局部变量域中进行赋值就冲突了,global是声明函数中的a仍是在全局变量域中在操作，
['c']        虽然身在局部变量域中，但操作是在全局中进行操作的。。

>>> a
1
>>> def jy(x):
...   print(x)  输出局部变量
...   x=3      改变局部变量绑定对象
...   print(x)  输出局部变量 
>>> jy(a)
1
3            当全局变量的对象传入到函数中，实际上是局部变量也绑定了这个对象
>>> a        
1
总之记住一点，当可变的全局变量作为对象传入进来，只要不改变全局变量绑定的地址，也就是不再进行赋值，对全局变量储存值进行修改是可以的，也就是传入是可变对象时是可以的，编程的时候尽量跳过这些。
```

软件开发原则，多用局部变量，少用全局变量，这样每个人编写的代码互相不影响

注意函数名也是一个全局变量，它绑定的是后面的函数代码块

globals,locals方法都是返回变量的字典，**globals返回全局，locals返回局部**，当然可以 global 全局变量

