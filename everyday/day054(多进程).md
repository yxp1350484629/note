# day054(多进程)

1.一个进程想占用计算机内核，我们称为占用cpu时间片。而这个由操作系统来给cpu分配进程。

2.操作系统来控制进程，还会在操作系统内存中开辟一片空间来记录进程信息，也就是进程控制块，这是操作系统查看寻找进程的标志

可以在Linux终端通过ps -aux来查看操作系统中的进程信息

记住，进程由程序发起，操作系统创建，操作系统分配资源，然后把创建好的进程给应用程序使用

3.除了操作系统启动自带的进程外，其余的进程基本上都有一个唯一的父进程，或多个子进程

比如我们在终端运行一个程序，这个进程就差不多是python3，然后父进程就是shell解释器，将shell命令解释，(因为python3....也就是shell命令)ubantu下shell解释器进程是bash，然后shell解释器的父进程就是终端

pstree命令可以查看进程树，也就是查看父子进程关系，这种结构主要是为了方便进程维护

每一个进程都有一个PID号，方便区分，PPID是该进程父进程PID（一般用ps -ajx查看)

4.进程三态

1.就绪态：进程创建完成，但是操作系统尚未分配资源，属于准备就绪的状态

2.执行态：操作系统给进程分配资源，进程占用cpu时间片，进程执行中

3.等待态：当进程中有IO阻塞的情况下，这个时候进程是绝对不会再占用cpu，会处于一个等待状态，当IO准备就绪后，再重新进入就绪态，等待系统分配资源。

进程五态

也就是在就绪态前面加了新建态，建立进程

在执行态后面加入终止态，终止进程，释放资源的过程

5.ps -aux 查看进程信息中的STAT状态，代表一个个进程现在处于什么状态

S 可中断等待 出现的最频繁的等待态，相当与我们的accept,recv。可以用ctrl+c来中断进程等待态

T 暂停等待态 相当于将进程等待态放在后端挂起的状态，比如accept,recv，用ctrl+z来放在后端挂起

R 运行态(包括就绪态) 由于就绪态的时间实在是太短，迅速到运行态。在编程中直接用R表示两个状态

Z 僵尸进程

 这四个状态信息，后面接<表示高优先级进程，后面接N表示低优先级进程，后面接+表示有前台进程，这个前台进程表示的是linux终端正在运行的，我们可以直接进行交互的进程。没有加+就是后台进程了。

用top命令可动态显示当前进程信息（可用> <翻页)，Ni代表优先级,注意优先级取值是-20-19，-20在最前面，他是最高优先级。

可以用nice 命令来设置优先级再执行程序 比如nice -9 python3 1.py 是设置1.py优先级为9,nice --9 python 1.py是设置1.py进程优先级为-9，注意0一下的优先级属于高优先级，一般需要用sudo

6.

1.进程之间是相互独立，互不影响的

2.进程是操作系统资源分配的最小单位

3.每个进程都占有相当大的运行内存，独立的内存空间。而这个运行内存是由一小块物理运行内存映射出来的虚拟内存

7.多进程（经典代码)

```python3
import os
pid=os.fork()  调用fork()创建新进程，下面的所有代码都由两个进程来执行(其实是复制了下面的代码给子进程)，                相互不影响，代码是没有生命力的而进程是有生命力的，相当于有了两个生命在执行下面的代码
if pid<0:      它们互不影响，输出结果都返回到终端
    print('错误')   
elif pid==0:
    print('开启新进程')
else:
    print('这是原进程')
    
这是原进程        这第一个进程就相当于父进程，它会执行fork()返回为子进程PID号
开启新进程        这第二个进程是子进程，不会执行fork()，但是会执行下一条赋值语句，没有执行就返回为0
第一个进程从import开始运行，第二个进程从=赋值开始运行（因为fork才创建子进程),代码是静止的，需要变为进程才会执行下去。关键是父进程把自己的下面代码以及自己的空间对象都复制一份给子进程，而进程都有自己独立的空间（运行内存)，子进程代码开始执行，两个空间代码和对象互不干扰。
父进程同样把自己独立空间中的对象复制给了子进程，但是两个独立空间中对象相互不影响了，两个进程也完全不相互影响
```

**运行代码，是将代码加载到操作系统内存中执行进程，给他再开一个进程是将进程内存独立空间中的对象和未执行完的代码复制了一份，给了新的进程独立空间**

一般fork都与if搭配，虽然下面执行的代码一样，但是不至于多开一个进程执行相同的代码，肯定要根据if来分开

os.getpid()获取自己进程的PID os.getppid()获取父进程PID

os._exit(任意整数)  sys.exit(a) a=0表示正常退出，也可以为a=字符串，然后会打印出来退出，其实都是系统进程异常退出。

8.孤儿进程

当父进程先结束的时候（程序运行完也是结束)，子进程就变成了孤儿进程，这个时候操作系统会给这些子进程分配系统进程作为他们的养父进程，维护进程树结构，最好是让子进程先结束。

僵尸进程

当子进程先退出，而父进程不进行任何处理，子进程就会遗留大量的PCB数据再操作系统中，形成僵尸进程。而孤儿进程永远不会成为僵尸进程，因为系统进程养父能把一切都处理好。