# day057(信号通信，同步互斥)

1.在不同进程中通过信号进行通信，就是信号通信

kill -l 在终端中查看系统所有的信号

kill -sig 进程号   在终端中向一个进程发送信号 - 后面是信号种类

在python中用os.kill模拟终端中的kill，第一个参数是PID号，第二个参数是信号

用signal模块里接口连接操作系统中的所有信号

其实终端也是用命令对操作系统进行操作，希望操作系统内核要执行什么，而终端也是一个进程

kill -sig 进程号 其实是终端进程执行接口函数将信息告知操作系统，然后操作系统给进程发送信号

2.

程序如何给自己本身发送进程信号呢

两种方式，第一种是os.kill第一个参数是os.getpid

第二个是调用signal模块中的特殊函数接口，比如alarm时钟，alarm(sec) 参数是秒数，它的执行是告诉操作系统内核，多少秒后，向自己本身这个进程发送终止信号，alarm后面的程序还会接着往下执行。当然所有的程序都是加载到操作系统内存中执行，基本上都是同步执行，就是一步一步来，但是这种方式实现了异步执行，通过操作系统的记录功能，延迟发送信号。

注意一个进程程序中只能有一个时钟，就是alarm，第二个会覆盖第一个时钟。

3.

signal.signal处理信号

这个是一种处理信号的方式，非阻塞，也是异步执行

这个第一个参数是信号，第二个参数可以有三种。

第一个种是默认处理，可以直接signal.signal(信号)忽略第二个参数。

第二种是忽略处理,signal.SIG_IGN，当有进程要操作系统发送信号给这个进程时，操作系统会直接忽略，不发送

第三种是函数处理，自己定义函数来处理，在定义函数的时候必须有两个参数，第一个参数是sig 信号类型，第二个参数是frame信号对象，定义时必须def 函数名(sig,frame)，但一般只会用到第一个参数，会默认把signal第一个参数信号类型传给sig,第二个参数不会用到，然后可以在函数里定义操作。最后也是传给操作系统记s录行为。

这个就相当于告知操作系统，我这个进程在要接受到这个信号时，需要这样处理，然后操作系统内核会记录，当有进程要发送这个信号给这个进程时，操作系统会反应过来，按照记录的处理方式执行。注意当操作系统记录这个东西，并不是一次性记忆，也就是并不是只会监控一次

4.信号量（信号灯）通信

和共享内存有异曲同工之妙，但各有各的用处，看情况来

multiprocessing中的Semaphore来创建信号灯，Semaphore(num) num为一个整数，就是给信号灯一个值，不同进程间，只要这个对象相同，就可以对这个值进行操作

信号灯对象有三个方法release,信号灯值加一，acquire,信号灯值减一，注意这个方法，当信号灯值为0时，他会变成一个阻塞函数，这也就是和共享内存区别之处，要适当运用

第三个方法就是get_value()获得信号灯值

5.同步与互斥

临界资源：多个进程都可以共享的资源，也就是前面通信用的介质

临界区：操作临界资源的那一段代码

同步：是一种合作关系，前面的通信管道和消息队列就是这种，必须里面有了，另一方才能收，否则就是阻塞。也就是指不同端的一种配合关系

互斥：指的是一种争夺与制约关系，典型的就是mysql的锁，当多方抢占一个资源的时候，有一方抢到，就给这个资源上锁，其他方就会阻塞，运用到进程对于共享资源的抢夺也是一样的道理

注意同步和互斥都依赖于阻塞

6.

基于同步与互斥对于资源的利用，python中有multiprocessing模块下的Event来控制不同进程对资源的使用，也是基于阻塞

用Event()来创建一个事件对象，只要进程这个对象相同，就可以控制状态

这个对象有wait方法，默认是阻塞状态，可以在后面设置阻塞时间timeout，超过时间就不再阻塞，也不会异常

当我们用Event对象执行set操作时，wait就不再阻塞了，使用clear方法时，set被清空，wait又恢复到了阻塞的状态。

如果多个进程都要对同一资源进行使用，可以用event对象来控制先后，频繁切换set和clear来达到同步。一般当一个进程使用资源的时候，别的进程都是在wait

7.

基于对互斥对于资源的利用，python中有multiprocessing模块下的Lock锁来控制不同进程对资源的使用

锁是一种约定，必须所有进程都遵循这种约定，才能束缚，列如之前的mysql给所有用户加上表级锁行级锁，当有用户对表进行操作，上锁，其他用户就阻塞在哪

在进程之间同样是这样

用Lock对象的acquire来给某个进程加上锁，（前提是其他进程也必须使用锁，acquire)这样其他进程的acquire就变成了阻塞状态，阻塞进程继续运行。必须是已经执行acquire的对象执行release来解锁，其他用户的acquire才能继续执行。

也可以用with Lock对象:  这样上锁。后面接代码块，代码块结束后就解锁，这样方便很多

也就是谁先抢到，就上锁，其他进程不能执行。实现了互斥

