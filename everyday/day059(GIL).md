# day059(GIL)

1.GIL是python的全局解释器锁，对于每一个程序运行的每一个进程都会加一个GIL全局锁，一个进程同一时间只能有一个线程运行。

也就是说一个进程最多同时只能由一个线程在cpu核上跑，即使是多核也用，看样子就像是单核，但是在cpu密集型程序里，它连单核多线程都不如，因为线程频繁在切换，还大大降低了效率。

在有延迟的程序里，比如IO进程，python多线程才能派上用场

CPU密集型程序，请用进程，进程池

2.

Python多线程与多进程中join()方法的效果是相同的。

下面仅以多线程为例：

首先需要明确几个概念：

知识点一：
当一个进程启动之后，会默认产生一个主线程，因为线程是程序执行流的最小单元，当设置多线程时，主线程会创建多个子线程，在python中，默认情况下（其实就是setDaemon(False)），主线程执行完自己的任务以后，就退出了，此时子线程会继续执行自己的任务，直到自己的任务结束，例子见下面一。

知识点二：
当我们使用setDaemon(True)方法，设置子线程为守护线程时，主线程一旦执行结束，则全部线程全部被终止执行，可能出现的情况就是，子线程的任务还没有完全执行结束，就被迫停止。。

知识点三：
此时join的作用就凸显出来了，join所完成的工作就是线程同步，即主线程任务结束之后，进入阻塞状态，一直等待其他的子线程执行结束之后，主线程在终止。所以join只有在守护进程中有作用，依赖于timeout。

知识点四：
join有一个timeout参数：

1. 当设置守护线程时，含义是主线程对于子线程等待timeout的时间将会杀死该子线程，最后退出程序。所以说，如果有10个子线程，全部的等待时间就是每个timeout的累加和。简单的来说，就是给每个子线程一个timeout的时间，让他去执行，时间一到，不管任务有没有完成，直接杀死。
2. 没有设置守护线程时，主线程将会等待timeout的累加和这样的一段时间，时间一到，主线程结束，但是并没有杀死子线程，子线程依然可以继续执行，直到子线程全部结束，程序退出。

daemon参数的作用

1）主线程不是守护线程，daemon属性的值为False；

2）新线程被创建时会继承父线程daemon属性的值；

3）主线程创建的所有子线程都默认daemon=False，如果要修改子线程daemon属性值，必须在调用start()方法启动线程之前进行；

4）主线程退出时会检查是否有daemon=False的子线程，如果有则延迟退出；如果当前所有子线程的daemon都是True，则主线程直接退出，同时所有daemon=True的子线程都会被强制结束；

5）所有daemon=True的子线程有可能遭遇被强制退出，其中的资源可能无法正确释放，从而有可能（但不一定）引发异常；

6）主线程结束也就意味着整个程序退出，进程结束。

**总结：**

为什么daenon默认为false对子进程影响不大，因为无论子进程多久执行完，主进程都会等待子进程结束后再结束，join只是一个标志，阻塞在那个地方的标志。

而daemon设置为True，主进程结束对于子进程影响巨大，那么主进程join()就没有作用了，因为不会因为子进程没执行完而阻塞。timeout也只能撑一段时间

注意join可以用来处理子进程变为僵尸进程

可以提前用代码让系统自动处理子进程发过来的信号



3.socketserver模块

socketserver模块是别人封装好的模块，我们一般用到的就是

与TCP有关的几个类

注意一般我们需要定义两个类，一个是Server，需要继承TCP创建封装类和TCP多进程（线程）类

注意，继承两个类，每个类的功能单一，符合高内聚原则

另一个类是Handler类，我们需要继承TCP请求处理类，并且重写类中的handler方法，这个就相当于我们在连接后需要做的事情，写在这个类中

Server创建对象一般需要两个参数，一个就是ip地址，一个就是处理的Handler了，相当于这两个类功能聚合在了一起。

在Handler类中，通过self.request属性来得到客户端套接字。



4.协程

我们运行一个程序，在应用层运行，将代码加载到内存中，系统开辟一个进程，动态的一直运行下下，但是一个进程是无法一直占在一个cpu上运行下去，肯定会有时间片分配等，会不断切换运行，这个时候在内存中，会默认记录一个点，运行到哪那个点就在那

而协程，是将要进行协程的程序的一个个类，一个个函数分为各自的栈区，在运行内存中给这些个栈区执行到那，阻塞了，就记录这个点，然后去运行其他栈区的代码，哪里的栈区没有阻塞就运行哪里，同时记录下运行到的点，就是通过记录的这些点，然后不断切换运行，达到效率的最大化。

由于这些记录点不是由操作系统记录，所以不会耗费操作系统资源，真正耗费操作系统资源的是进程，操作系统需要给进程分配时间片，让他可以在cpu上跑，线程用的是进程的资源，而这些记录点都在内存中，所以不耗费内核资源，协程的资源消耗极少，但是提高了效率

优点：耗费极少的操作系统资源

​           极好地支持了IO并发，python一般用多进程+协程

​            由于是单进程，协程不需要cpu切换地开销

​             不需要同步互斥

缺点：单进程且只能在一个动态中完成，不支持多核。

在python中协程地基础是依赖于yield。有一些封装了yield的协程库



gevent库

gevent.spawn(func,avgs)

spawn函数是创建一个协程对象，通过一个个函数，也就是一个个栈区，我们可以把要进行协程操作的代码写入一个个函数，然后用spawn给这些函数创建对象，就能把这些函数变为协程监控的区域了，当然主进程代码也是协程监控的区域，当协程函数中的代码阻塞就跳到主进程，主进程代码阻塞了就会跳到函数。哪里没有阻塞就跳到哪里。

**注意只要将函数添加到spawn就形成了自己独立的协程空间，就是自己独立的栈区，把相同的函数添加到其中，也是创建不同的对象，建立不同的栈区，会自动监控所有程序，非协程函数代码阻塞就跳到协程代码，协程代码阻塞就跳到非协程函数代码**

gevent.sleep（sec） 用于创建协程对象的函数中，起到阻塞作用，可跳到其他栈区，同时记录下这个点

gevent.joinall([协程对象]) 两个作用，一是起到了开头的作用，在主进程代码中阻塞，这样就会跳到协程代码

二是等协程代码运行完可以回收协程对象

当然我们更多是想把协程运用到IO上，和IO的相关阻塞相匹配，这个时候需要脚本函数了

从gevent中调用monkey

monkey.patch_all()函数可以在导入socket的时候，修改其中的代码，让相关的IO阻塞都变为协程阻塞，这样就运用到协程中了，记得要在import socket之前