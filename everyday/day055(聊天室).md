# day055(聊天室)

1.僵尸进程处理方法

通过父进程来处理

pid,status=os.wait() 阻塞函数，当子进程退出的时候，会自动处理子进程，避免成为僵尸进程。这个wait一般放在后面，就算是子进程先退出，这个也能捕获到遗留下来的僵尸程序

通过把子进程间接变为孤儿进程来处理

就是父进程先开一个子进程，随后wait，然后子进程开一个二级子进程，随后子进程立即结束，这样父进程就不需要等待太久，直接wait捕获，而二级子进程由于失去父进程变为孤儿进程，系统继父很牛逼。这叫间接转化。

2.在聊天室中，见day5聊天室项目，我在服务端父进程中定义的user来储存用户及地址，在子进程中定义管理员收发，主要是父进程中改变了user，但是父子进程中的user变量并不是绑定同一个对象。（不是单进程的多绑定)

只是相当于在父子进程分割的时候，把父进程中的user对象复制了一份给子进程，其余的就互不干扰了。注意父进程中的套接字对象监听窗口。也可以复制一份给子进程，并不是另一个套接字又绑定了一次ip，（创建绑定ip只有一次，就是在父进程中的那次绑定) 而是直接复制了对象，相当于相同两个对象监听同一个窗口，是可以的

3.multiprocessing模块process类创建多进程

重点就在于绑定函数，执行start开启进程，执行 join回收进程

函数相当于一个功能，开启一个进程主要就是完成一个功能，process相当于执行fork中等于0的那部分，但是和fork不一样的是fork会复制执行赋值后的所有代码，而process只用执行函数中的代码，这样有利于创建更多的进程，而多个fork堆叠在一起，第一个fork会执行下面所有fork

process中父进程就相当于完成创建process对象,start开启进程，还有父进程需要回收僵尸进程用join，注意join会**阻塞当前进程，直到调用join方法的那个进程执行完，再继续执行当前进程** 

很多时候，当有多个进程的时候，在multiprocessing多进程中，父进程只需要负责多个子进程的创建，start,join

process参数 name进程名称 target绑定函数 args参数绑定传参元组，kwargs传参字典。这个传参很多时候没必要，因为可以直接用父进程中的变量，而传参很多时候也是需要父进程的对象，这个传参是函数中需要父进程没有的对象才需要传参。

4.（牢记)

子进程使用父进程对象，是复制了对象，但是共用了一套属性，为什么父进程创建套接字，绑定ip地址，子进程复制没有重用端口，因为共用了端口属性。为什么在父进程中创建文件流，子进程进行文件操作后，读的位置会改变，因为读是根据seek到哪个位置，只是f的属性，子进程复制了f对象，可以进行操作，但是和父进程f共用了属性，子进程读了也会改变那个位置（注意这个对象公用一套属性只在对象与文件，网络相关联的时候才会出现)

```
lass ol:
    def __init__(self,a,b):
        self.a=a
        self.b=b        这种并没有共用属性，现阶段只与网络，文件相关联的对象才会共用
A=ol(1,2)               不过方法也算是类的属性，都是变量，但上述还是只在哪两种情况出现
def p2():
    A.a=3
    print(A.a)
def p1():
    A.a=2
    print(A.a)
p1=Process(target=p1)
p2=Process(target=p2)
p1.start()
p2.start()
sleep(1)
print(A.a)
2
3
1
```

5.p.is_ alive  返回真假，判断进程是否生存

p.name进程名 p.pid进程号PID   当然这些都是在父进程中运行的

p.daemon  默认为False  当主进程结束的时候，不会影响到子进程

p.daemon=True  设置为True 当主进程结束的时候，子进程会随之结束 

daemon不与join同时使用，用了join一定会等子进程结束父进程才会结束

记住给进程设置属性一定要在start之前，进程开始了再设置一些属性就没用 

6.自定义进程类

**run：**如果在创建Process对象的时候不指定target，那么就会默认执行Process的run方法 。继承Process类，肯定就要重写run方法

1.继承Process类

2.在init方法中调用父类init，父类init默认不需要参数，可以直接super().__ init __()

3.重写父类中的run方法，因为调用start是调用了run方法，通过重写run方法，来实现进程需要干什么事情

这样也可以开启了一个进程，创建进程对象，可以自定义要干什么事情