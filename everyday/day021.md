# day021

1.一般在程序最前面加上# encoding:utf-8

python builtins模块是在一个程序文件编辑时就自动导入了的 想用也是系统赋值好变量给你用

它存在于内建模块里面，其实还有math等都属于内建模块

2.sys系统模块

内建模块的一种 返回的是当前python解释器绑定的一系列信息

sys.path 是标准库的路径，当我们想导入模块时，就从这些路径的库中寻找

sys.modules Python启动时，系统需要加载的模块

查看python解释器的版本

import sys

sys.version  字符串返回

sys.version_info 元组返回

或者在终端窗口

python3--version

sys.platform 查看当前的操作系统

sys.argv 绑定用户在终端窗口启动程序时输入的语句（命令行参数），以列表的形式存储。

3.模块1.names  模块2.names 相当于是两个不同的变量

4.import搜索顺序

当前路径

sys.path路径 标准库

内建模块

5.import 模块

都会把模块中的代码都执行一遍，因为只有执行了才会创建那些对象，创建模块，创建函数等对象

但是第二次再import该模块就不用再执行了，因为已经存在那些对象了

如果我们再导入后 修改模块 是不会立即反应到程序中的，因为解释器认为已经存在这个模块对象了，那么导入也就没啥用了，只能重启，或者使用模块中的主管imp，这个就是专门管模块的

可以调用方法 imp.load(模块) 来重新导入

.py--->.pyc---------->python        其实.py都是给人看的 ，解释器需要把这些文件转化为字节码给计算机看解释执行

​     编译     解释执行

但是这些本来都是应该在计算机内部执行

pyc文件，是python编译后的字节码（bytecode）文件。只要你**运行了py文件**，python编译器就会自动生成一个对应的pyc字节码文件。这个pyc字节码文件，经过python解释器，会生成机器码运行（这也是为什么pyc文件可以跨平台部署，类似于java的跨平台，java中JVM运行的字节码文件）。下次调用直接调用pyc，而不调用py文件。**直到你这个py文件有改变。python解释器会检查pyc文件中的生成时间，对比py文件的修改时间，如果py更新，那么就生成新的pyc。**

下面介绍下什么时候会生成.pyc文件：

在你 import 别的 py 文件时，那个 py 文件会被存一份 pyc 加速下次装载。而主文件因为只需要装载一次就没有存 pyc，你可以写两个 a.py 和 b.py，一个 import 另一个试试看。在你 import 别的 py 文件时，那个 py 文件会被存一份 pyc 加速下次装载。而主文件因为只需要装载一次就没有存 pyc，你可以写两个 a.py 和 b.py，一个 import 另一个试试看。
可能是因为设计者认为被导入模块，可能被导入多次，执行多次，所以就加一个pyc,这样既提高了效率，也节省了效率。pyc时间和源码时间相比较，解释器来判断需不需要创建一个新的pyc

主程序是肯定要转化为字节码文件然后py解释器执行的，但是如果我们每次导入的那些模块都要进行一次编译然后执行的话，就太浪费资源了，所以就加个pyc文件，不用每次导入都编译一次模块内容。