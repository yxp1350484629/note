# bday022

1.模块对象的属性就是变量，变量绑定对象

2.属性有全局变量属性和预置属性

预置属性也就是打开python编辑界面，系统给你已经 创建的变量

dir函数查看所有属性，而__all__只能查看全局变量属性

__ doc __绑定的是文档字符串，文档字符串连续回车两次，也就是有两个\n，就会将下面的内容变化为description，将上面的内容接在name（也就是模块名）的下面，起到了一个标题的作用。如果不空一行，那么所有的内容都会是description,也就不把一些字符接在name哪里了

注意help中的name并不一定是 __ name __ 属性

__ file __对应的是文件的地址，如果这个模块是我们自己写的，那么它的file属性绑定的就是文件路径

如果这个模块是内置的模块，help显示的__ file __属性绑定的是 built-in ，但是模块调用属性其实就是没有

__ name__ 属性最大的作用就是判断自己是不是主模块，因为如果该模块是最先被启动，也就是它调用别的模块，那么他就是主模块，此时这个模块的预置属性绑定的就是 __ main __

但如果是模块被其他模块调用，此时该模块的__name__预置属性就是模块的名字。

3.sys.modules 绑定的是解释器已经导入的模块

4.import 导入其他模块所有的时候，是不会导入它的预置属性的，(但是点记法任然可以访问)因为设定的就是无法被导入，导入岂不是一大片冲突，虽然预置属性在自己模块内部可以直接使用，但切记不会被导入到其他模块中,虽然import 模块能将整个模块对象导入，但是那些变量仍然存在于模块对象中，from 模块 import *，也只能导入模块里的全局变量，不过通过.记法可以访问模块里的所有属性

5.**记住 导入模块是先执行一遍，创建变量和对象，然后在主模块中创建和被导入模块同名变量，然后绑定了对象，导入模块中的变量，也是如此**。

6.在团体合作中，设计模块，通常都会在模块中使用__ all __=[被导入的变量名]  来选择那些变量被导入，列表中是以字符串形式的一个个变量名。这样是最适合的，这样别人可以直接用from 模块 import * 来调用，基本上很多模块都是这样写的，为了不把别人的变量覆盖，也能让别人调用时方便。也可以直接通过dir()来查看增加了那些变量，然后通过help来查看变量功能

注意 __ all __只是针对了from 模块 import *  这是隐藏的规则，记住还有一个隐藏的规则，就是变量名 以下划线开头，那么from 模块 import *不会导入该变量。

但是import  模块，是将整个模块对象导入了，然后.记法可以访问所有变量

7.

import导入包，其实就是导入包中的__ init __ 模块，也当然执行了__ init __。它的意思就是初始化，告诉解释器这是一个包，所以import 包，其实是导入了一个模块，也就是导入了一个包的空壳，包中的其他模块，包并未被导入。也就是说其他的变量属性并未执行，哪些对象也不存在，上面的导入模块是产生了所有对象，并用属性来绑定。但是包不同，包只是执行了那个初始化模块，告诉解释器这是一个包，**其实包也就是一个模块，导入自始至终只能算是导入模块，但是这个模块中算是间接包裹其他模块**，但是未被导入。如果想导入包中的模块，子包，需要用点记法，来执行里面的模块，子包，创建对象导入，用变量绑定。

用点记法导入了子包也只是导入了它的 __ init __模块，如要再用.才能导入模块

**注意 当模块未被导入，是不能直接用包. 来访问模块的，因为包只是导入了 __ init __模块，并未导入内属性对象**

也可以用from  import 来使用，很灵活

注意 如果直接导入包中的子包，那么包中的 __ init __也会被加载，因为得先有包框架，初始化，解释器才知道只是一个包。同样直接用点记法导入包中的模块得时候，也是一级一级的先要调用外层的包，记住只是调用了包中的那个，让解释器知道是包。和箱子得道理是一样的，不会调用其他的，但是一级一级得调用执行，终究的原理是调用模块。成包——成包——模块