# day081(django)

1.分布式路由处理（实现以包为单位的模块化)

我们在主文件夹下的相同文件名文件夹下的urls.py，是总的url处理枢纽，基本上任何url请求进来（除了静态文件请求)都要经过它，然而，这个urls可以根据路由做分布式处理，就是把路由分解分类

例如，路由前面都是music的，由这个应用urls处理，路由前面都是index，由这个应用urls处理

就是可以处理多个类别的url给多个相应的应用处理，这样避免了所有url都写在主的urls里面

注意，在主的url下面写了r'music/'  ，对应应用的url就不用再前面加/，同理如果前面没加/，后面就要加/

拼接起来是个完整的路由就行了，主的urls把该类的url所有东西都交给应用处理了，只需要在后面绑定include('应用名.urls')，注意在urls中urlpatterns必须同名

至于模板之类的能不能在应用中使用，已经在设置中规定好了模板的路径，当然是可以在应用的views中调用的。

而静态文件，根本就不走url解析，只要出现了请求路径是主文件中规定的，就直接在存储位置找了

注意setting只在主文件目录有

2.orm在程序层面上解决的default问题，就是你没输入数据时，会在程序层面上给你默认你设置的，再添加到数据库中，而数据库表看结构，还是null，这没关系的。

3.Duplicate entry在插入数据到数据库中会时常出现，说明了重复插入，肯定有唯一索引

4.我们在django中做好orm数据库，在源数据库中可以进行数据的添加删除，但是切记不要改变表任何结构，因为这样和django中的model就不匹配了

5.django shell是在加载时以加载当时的文件配置为基础，如果更改了一些，而正好在django shell要用这个，最好重启下django shell

6.为了更好的可视化类对象，最好在类中可以定义__str __

7.（重点)

'DIRS': [
            os.path.join(BASE_DIR,'templates')
        ],
        'APP_DIRS': True,

这个是django设置下面模板设置的主文件的templates和应用的templates

在django中，如果这两个设置都是有的，即使是在应用中的视图里找模板，也会优先在DIRS里面的模板路径找，找不到，再从每个应用中的templates里面找。

注意，这个并不是在那个app，就在自己应用的templates找，而是根据设置中导入app那个设置的导入顺序，寻找里面的templates，假如不同应用的templates有相同文件名的模板，就会出现问题，可能找到的就是其他应用的模板，因为是按照设置的导入顺序寻找

最好的办法是在每个应用的templates下面还加一个文件夹，这个文件夹名一般设置为自己的应用名，比如在应用bookstore的视图中找的时候，比如render，需要的模板就变成了 ‘bookstore/index.html’，每个应用的templates下面都再加一个和自己应用名相同的文件夹，这样也就独一无二了，即使是按顺序找，也会找到对应的

一般在主文件下的templates，公司会放置集中处理的模板，比如404 500返回的一些模板

而对于每个小组，也就是每个应用都是自己发挥，但是要区别开来，上面的方法是最好的。

8.

当我们进行表记录查询的时候，没有查询到数据,QuerySet就会为空，相当于QuerySet[]

我们很多时候在视图层，没有查询到数据需要进行判断，if not 查询结果或者len(查询结果)==0都是可以的

所有返回是QuerySet对象，都可以这样判断是否有数据

所有返回结果是QuerySet对象,都可以通过这个对象.query，来查看这个查询结果调用的原生sql语句是什么样的，有时候可以帮助我们判断复杂的情况

**当然我们可以通过type来查看返回结果对象是不是QuerySet对象**

9.当用表单传过来数据的时候，我们不管前端是否在页面上进行的空不能提交，作为一个后端工程师，都要判断下数据是否为空

10.注意当request的POST,GET返回来的是QueryDict查询字典的对象，这个对象使用get方法，是根据键查询，**如果没有这个键，就会返回get方法第二个参数。**如果没有查询到值就会返回''空字符串

11.我们呢要尽量高度统一字段的类型，就是数据库中的字段类型是什么，我们在django视图中，传值的时候，也要是什么类型

12.我们用模型类创建的对象，就是model对象，而查询出来的Qeruyset里面存放的也是model对象，（注意用values得到的Qeruy里面是一个个字典),一个model对象就代表一条记录，可以对象.属性来创建，修改该记录的字段值，save就是将修改的内容保存，保存后还可以继续修改然后保存，只要对象不delete就可以一直进行操作

我们用查询出来的Qeruyset遍历出model对象，也可以用这个model对象来进行上面的操作，这个对象都是一样的,当然也可以直接用Qeruyset的方法进行整体操作

13数据的假删除和真删除

假删除通常在企业中是这样的，就是给表添加一个字段isActive，默认为True,要是想删除这条记录，就把该记录的这个字段值设置为False，我们进行表数据查询的时候，只显示isActive为True的字段的记录，也就达到了伪删除的作用