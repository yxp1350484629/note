# day064（mongodb)

1.固定集合

和创建普通集合一样的方式，可以用函数创建，createCollection('集合名',{capped:true,size:1000,max:100})

这是创建集合，capped:true 表示集合是固定的，大小为1000字节，最多能存放100个文档

这两个限制无论哪一个达到，都会挤出之前的数据，注意固定集合是固定大小，当满了会挤出之前的数据

优点：可以自动清除早期数据，可以提高存储和查询速度，可以控制集合空间的大小

这个提高存储和查询速度是因为集合大小固定，当文档存储在磁盘的时候，文档很大，是不会连在一块存储在磁盘里的，是会分块存储，而固定集合也是数据库文件，大小固定，存在磁盘上会连在一起，这样查找就不会几个块查找写入，提高了读写速度

适用于：超市购物信息，磁盘缓冲区。

之前的网络编程缓冲区是在内存里，主要是为了协调收发速度，减少读写次数，但是内存空间有限。磁盘缓冲区可以更大作为临时缓存，可用固定集合



2.文件存储方法

地址存储，可以在mongo中用文档存储文件名及信息，还有文件的路径，要用的时候直接使用路径就行，注意路径要存储绝对路径。

这种方法不好的地方在于当数据库迁移到别的电脑，以及文件路径改变需要修改数据库内容，尤其当有大量路径的时候，不太好修改

文件存储，直接将文件以二进制的方式存储于数据库中，注意不同的数据库会有不同的二进制格式，时间格式，这种方法一般适合于存储不大的文件，存储太大文件太占磁盘空间，当然也避免不了大的文件也要存储在数据库中的情况

mongofiles -d 数据库名称（没有就创建一个) put 文件名 

在shell命令行

mongo中存储大的文件

GridFS存储大文件 在mongo中文件大于16M就是大文件

在mongo中用两个集合相配合的方式存储大文件

fs.files 存储文件的相关信息

fs.chunks 存储文件的内容 文件内容根据大小分为多个块，因为是存在磁盘上，太大要分多个块

fs.files的系统_id和fs.chunks中的files_id是相同的，fs.files中只需要一个文档来存储信息，有独一的 _id,而

fs.chunks中的数据太大，一个文档放不下，要分为多个文档，_id都不相同，这样如何知道那些文档是一起的呢，就加一个 files_id,让它们都相同。这也给我们提供了多个集合，文档存储一个文件的经验，也就相当于一对多

文件提取方法

mongofiles -d 数据库名 get 文件名  从数据库中下载到当前文件夹

3.游标

游标中存储的结果，可以一次返回一个数据，效率高

mongo内部支持js，可以在mongo命令行，声明一个游标对象

var cursor=db.class.find()    之后可以不断cursor.next()不断返回



4.python与Mongo交互

使用第三方模块pymongo

老师说的话：对原理性的问题，探索得越多，能解决得事情就越多

第一步：建立连接对象

conn=pymongo.MongoClient('localhost',27017)

注意有这个连接对象后，就可以使用mongo中所有的数据库，用点记法

第二步：建立数据库对象

db=conn.数据库名  有了数据库对象就可以使用所有的集合

第三步：建立集合对象

myset=db.集合名 有了集合对象后就可以进行一系列的文档操作了

注意我们最好不要pymongo.MongoClient('localhost',27017).数据库名.集合名，因为这样我们要使用其他的数据库，其他的集合又要再建立连接

这样一步步来，可以保留连接对象，数据库对象，集合对象

第四步：集合操作

调用myset对象中的各个函数，很多函数和mongo本身的函数差不多

由于Mongo中的很多操作需要{}和[]，python中的相关方法都可以用字典和列表，其实python中的相关方法和mongo中的使用类似，只不过转换为python的格式

本质是python中的函数输入的语句通过字符串解析转化为对应的mongo语句，给mongodb

插入语句

集合对象.insert([{},{},{}]) 列表内放入多个字典，插入多个文档

集合对象.save({}) 放入一个字典，字典的语句转化为mongo语句执行，如果_id值重复，就会替换掉之前的

查找语句

基本上所有的语句都和mongo中的差不多，只不过域名，操作符都要加上引号，python中没有文档的概念，只有字典。

一般在编程层面用的多的也就是查找，插入，删除。

find函数返回一个游标，这个也好理解，如果用find函数只是把数据打印出来，那么没有什么意义，我们在编程中更多的是可以操作这些数据，就把它保存在游标内，游标内存放的是一个个字典

可以用for循环来迭代游标，又可以用游标调用next方法，注意在Mongo中我们可以根据查询出来的结果在后面进行操作，比如limit,sort等。在python中也是在游标对象的后面进行操作

但是当运行了for ,next后，就不能再用这些函数了，因为游标的位置变了，不是指向第一条数据，而limit,sort，skip,count等都要从第一条数据开始

提一下sort方法和mongo中不太一样，python把这里变了，用[()...] 用列表中的一个个元组来进行操作

find_one方法 注意python中用下划线隔开函数方法是python的习惯，返回一个字典，因为在mongo中是返回一条结果，在python中就成了一个字典

我们一般可以把find({},{})后面的第一个字典用变量在外面写好，直接传入，因为在python中不相当于在mongo中，如果语句过多，可以这样操作简洁



修改函数update

在Mongo中update有四个参数，后两个参数为true,false,而在python中只有True,False.所以在写这些的时候，python可直接用True,False表示，不加引号，没有加引号的概念。

在python中True,False,None 对应Mongo中 true,false,null

update_many在python中默认将第四个参数设置为True，就不用手动添加了，因为是插入多条数据，就系统设置为True了。

update_one是将第四个参数默认设置成为False。

而且这是在python的函数中，支持变量名传参，可以不按顺序传参



删除函数remove

在python中是自动将第二个参数设置为True,意思是找到就删除所有记录。而在mongo中是设置为false，也是这个意思。我们当然可以在python中设置multi=False



聚合操作 agreegate

和find一样返回游标对象，可对其遍历

聚合操作还是用的到的，和mongo中一样，记得打上' '



我们可以根据游标返回的数据遍历，然后得到每条记录的_id，然后就可以对每条记录进行操作



四种在Python读写大文件于ｍｏｎｇｏ的方法，在ｄａｙ４最后一节里



 







































































.





